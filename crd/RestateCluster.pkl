/// RestateCluster describes the configuration and status of a Restate cluster.
///
/// This module was generated from the CustomResourceDefinition at <file:./crd/crd.yaml>.
module dev.restate.v1.RestateCluster

extends "package://pkg.pkl-lang.org/pkl-k8s/k8s@1.0.1#/K8sResource.pkl"

import "package://pkg.pkl-lang.org/pkl-k8s/k8s@1.0.1#/apimachinery/pkg/apis/meta/v1/ObjectMeta.pkl"
import "package://pkg.pkl-lang.org/pkl-k8s/k8s@1.0.1#/api/core/v1/PodSpec.pkl"
import "package://pkg.pkl-lang.org/pkl-k8s/k8s@1.0.1#/api/core/v1/EnvVar.pkl"
import "package://pkg.pkl-lang.org/pkl-k8s/k8s@1.0.1#/api/core/v1/ResourceRequirements.pkl"
import "package://pkg.pkl-lang.org/pkl-k8s/k8s@1.0.1#/api/core/v1/Toleration.pkl"
import "package://pkg.pkl-lang.org/pkl-k8s/k8s@1.0.1#/api/networking/v1/NetworkPolicy.pkl"

fixed apiVersion: "restate.dev/v1"

fixed kind: "RestateCluster"

/// Standard object's metadata.
///
/// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>.
metadata: ObjectMeta?

/// Represents the configuration of a Restate Cluster
spec: Spec

/// Status of the RestateCluster. This is set and managed automatically. Read-only. More info:
/// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
status: Status?

/// Represents the configuration of a Restate Cluster
class Spec {
  /// clusterName sets the RESTATE_CLUSTER_NAME environment variable. Defaults to the object name.
  clusterName: String?

  /// Compute configuration
  compute: Compute

  /// TOML-encoded Restate config file
  config: String?

  /// Security configuration
  security: Security?

  /// Storage configuration
  storage: Storage
}

/// Compute configuration
class Compute {
  /// Affinity is a group of affinity scheduling rules.
  affinity: Affinity?

  /// Specifies the DNS parameters of the Restate pod. Parameters specified here will be merged to the
  /// generated DNS configuration based on DNSPolicy.
  dnsConfig: PodSpec.PodDNSConfig?

  /// Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are 'ClusterFirstWithHostNet',
  /// 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the
  /// policy selected with DNSPolicy.
  dnsPolicy: String?

  /// List of environment variables to set in the container; these may override defaults
  env: Listing<EnvVar>?

  /// Container image name. More info: https://kubernetes.io/docs/concepts/containers/images.
  image: String

  /// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is
  /// specified, or IfNotPresent otherwise. More info:
  /// https://kubernetes.io/docs/concepts/containers/images#updating-images
  imagePullPolicy: String?

  /// If specified, a node selector for the pod
  nodeSelector: Mapping<String, String>?

  /// replicas is the desired number of Restate nodes. If unspecified, defaults to 1.
  replicas: Int?

  /// Compute Resources for the Restate container. More info:
  /// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  resources: ResourceRequirements?

  /// If specified, the pod's tolerations.
  tolerations: Listing<Toleration>?
}

/// Affinity is a group of affinity scheduling rules.
class Affinity {
  /// Describes node affinity scheduling rules for the pod.
  nodeAffinity: NodeAffinity?

  /// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as
  /// some other pod(s)).
  podAffinity: PodAffinity?

  /// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone,
  /// etc. as some other pod(s)).
  podAntiAffinity: PodAntiAffinity?
}

/// Describes node affinity scheduling rules for the pod.
class NodeAffinity {
  /// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified
  /// by this field, but it may choose a node that violates one or more of the expressions. The node that
  /// is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of
  /// the scheduling requirements (resource request, requiredDuringScheduling affinity expressions,
  /// etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum
  /// if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the
  /// most preferred.
  preferredDuringSchedulingIgnoredDuringExecution: Listing<PreferredDuringSchedulingIgnoredDuringExecution>?

  /// If the affinity requirements specified by this field are not met at scheduling time, the pod will
  /// not be scheduled onto the node. If the affinity requirements specified by this field cease to be
  /// met at some point during pod execution (e.g. due to an update), the system may or may not try to
  /// eventually evict the pod from its node.
  requiredDuringSchedulingIgnoredDuringExecution: RequiredDuringSchedulingIgnoredDuringExecution?
}

/// An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A
/// null preferred scheduling term matches no objects (i.e. is also a no-op).
class PreferredDuringSchedulingIgnoredDuringExecution {
  /// A node selector term, associated with the corresponding weight.
  preference: Preference

  /// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
  weight: Int
}

/// A node selector term, associated with the corresponding weight.
class Preference {
  /// A list of node selector requirements by node's labels.
  matchExpressions: Listing<MatchField>?

  /// A list of node selector requirements by node's fields.
  matchFields: Listing<MatchField>?
}

/// A node selector requirement is a selector that contains values, a key, and an operator that relates
/// the key and values.
class MatchField {
  /// The label key that the selector applies to.
  key: String

  /// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists,
  /// DoesNotExist. Gt, and Lt.
  operator: String

  /// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If
  /// the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or
  /// Lt, the values array must have a single element, which will be interpreted as an integer. This
  /// array is replaced during a strategic merge patch.
  values: Listing<String>?
}

/// If the affinity requirements specified by this field are not met at scheduling time, the pod will not
/// be scheduled onto the node. If the affinity requirements specified by this field cease to be met at
/// some point during pod execution (e.g. due to an update), the system may or may not try to eventually
/// evict the pod from its node.
class RequiredDuringSchedulingIgnoredDuringExecution {
  /// Required. A list of node selector terms. The terms are ORed.
  nodeSelectorTerms: Listing<NodeSelectorTerm>
}

/// A null or empty node selector term matches no objects. The requirements of them are ANDed. The
/// TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
class NodeSelectorTerm {
  /// A list of node selector requirements by node's labels.
  matchExpressions: Listing<MatchField>?

  /// A list of node selector requirements by node's fields.
  matchFields: Listing<MatchField>?
}

/// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some
/// other pod(s)).
class PodAffinity {
  /// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified
  /// by this field, but it may choose a node that violates one or more of the expressions. The node that
  /// is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of
  /// the scheduling requirements (resource request, requiredDuringScheduling affinity expressions,
  /// etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum
  /// if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest
  /// sum are the most preferred.
  preferredDuringSchedulingIgnoredDuringExecution: Listing<PreferredDuringSchedulingIgnoredDuringExecution>?

  /// If the affinity requirements specified by this field are not met at scheduling time, the pod will
  /// not be scheduled onto the node. If the affinity requirements specified by this field cease to be
  /// met at some point during pod execution (e.g. due to a pod label update), the system may or may not
  /// try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes
  /// corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
  requiredDuringSchedulingIgnoredDuringExecution: Listing<RequiredDuringSchedulingIgnoredDuringExecution>?
}

/// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most
/// preferred node(s)
class PreferredDuringSchedulingIgnoredDuringExecution {
  /// Required. A pod affinity term, associated with the corresponding weight.
  podAffinityTerm: PodAffinityTerm

  /// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
  weight: Int
}

/// Required. A pod affinity term, associated with the corresponding weight.
class PodAffinityTerm {
  /// A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm
  /// matches with no Pods.
  labelSelector: LabelSelector?

  /// MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.
  /// The keys are used to lookup values from the incoming pod labels, those key-value labels are merged
  /// with `LabelSelector` as `key in (value)` to select the group of existing pods which pods will be
  /// taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the
  /// incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist
  /// in both MatchLabelKeys and LabelSelector. Also, MatchLabelKeys cannot be set when LabelSelector
  /// isn't set. This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
  matchLabelKeys: Listing<String>?

  /// MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.
  /// The keys are used to lookup values from the incoming pod labels, those key-value labels are merged
  /// with `LabelSelector` as `key notin (value)` to select the group of existing pods which pods will be
  /// taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the
  /// incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist
  /// in both MismatchLabelKeys and LabelSelector. Also, MismatchLabelKeys cannot be set when
  /// LabelSelector isn't set. This is an alpha field and requires enabling MatchLabelKeysInPodAffinity
  /// feature gate.
  mismatchLabelKeys: Listing<String>?

  /// A label query over the set of namespaces that the term applies to. The term is applied to the union
  /// of the namespaces selected by this field and the ones listed in the namespaces field. null selector
  /// and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all
  /// namespaces.
  namespaceSelector: NamespaceSelector?

  /// namespaces specifies a static list of namespace names that the term applies to. The term is applied
  /// to the union of the namespaces listed in this field and the ones selected by namespaceSelector.
  /// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
  namespaces: Listing<String>?

  /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
  /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
  /// whose value of the label with key topologyKey matches that of any node on which any of the selected
  /// pods is running. Empty topologyKey is not allowed.
  topologyKey: String
}

/// A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm matches
/// with no Pods.
class LabelSelector {
  /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
  matchExpressions: Listing<MatchExpression>?

  /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is
  /// equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and
  /// the values array contains only "value". The requirements are ANDed.
  matchLabels: Mapping<String, String>?
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates
/// the key and values.
class MatchExpression {
  /// key is the label key that the selector applies to.
  key: String

  /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists
  /// and DoesNotExist.
  operator: String

  /// values is an array of string values. If the operator is In or NotIn, the values array must be
  /// non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is
  /// replaced during a strategic merge patch.
  values: Listing<String>?
}

/// A label query over the set of namespaces that the term applies to. The term is applied to the union
/// of the namespaces selected by this field and the ones listed in the namespaces field. null selector
/// and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all
/// namespaces.
class NamespaceSelector {
  /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
  matchExpressions: Listing<MatchExpression>?

  /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is
  /// equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and
  /// the values array contains only "value". The requirements are ANDed.
  matchLabels: Mapping<String, String>?
}

/// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s))
/// that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where
/// co-located is defined as running on a node whose value of the label with key <topologyKey> matches
/// that of any node on which a pod of the set of pods is running
class RequiredDuringSchedulingIgnoredDuringExecution {
  /// A label query over a set of resources, in this case pods. If it's null, this PodAffinityTerm
  /// matches with no Pods.
  labelSelector: LabelSelector?

  /// MatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.
  /// The keys are used to lookup values from the incoming pod labels, those key-value labels are merged
  /// with `LabelSelector` as `key in (value)` to select the group of existing pods which pods will be
  /// taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the
  /// incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist
  /// in both MatchLabelKeys and LabelSelector. Also, MatchLabelKeys cannot be set when LabelSelector
  /// isn't set. This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
  matchLabelKeys: Listing<String>?

  /// MismatchLabelKeys is a set of pod label keys to select which pods will be taken into consideration.
  /// The keys are used to lookup values from the incoming pod labels, those key-value labels are merged
  /// with `LabelSelector` as `key notin (value)` to select the group of existing pods which pods will be
  /// taken into consideration for the incoming pod's pod (anti) affinity. Keys that don't exist in the
  /// incoming pod labels will be ignored. The default value is empty. The same key is forbidden to exist
  /// in both MismatchLabelKeys and LabelSelector. Also, MismatchLabelKeys cannot be set when
  /// LabelSelector isn't set. This is an alpha field and requires enabling MatchLabelKeysInPodAffinity
  /// feature gate.
  mismatchLabelKeys: Listing<String>?

  /// A label query over the set of namespaces that the term applies to. The term is applied to the union
  /// of the namespaces selected by this field and the ones listed in the namespaces field. null selector
  /// and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all
  /// namespaces.
  namespaceSelector: NamespaceSelector?

  /// namespaces specifies a static list of namespace names that the term applies to. The term is applied
  /// to the union of the namespaces listed in this field and the ones selected by namespaceSelector.
  /// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
  namespaces: Listing<String>?

  /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
  /// the labelSelector in the specified namespaces, where co-located is defined as running on a node
  /// whose value of the label with key topologyKey matches that of any node on which any of the selected
  /// pods is running. Empty topologyKey is not allowed.
  topologyKey: String
}

/// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone,
/// etc. as some other pod(s)).
class PodAntiAffinity {
  /// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions
  /// specified by this field, but it may choose a node that violates one or more of the expressions. The
  /// node that is most preferred is the one with the greatest sum of weights, i.e. for each node that
  /// meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity
  /// expressions, etc.), compute a sum by iterating through the elements of this field and adding
  /// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
  /// node(s) with the highest sum are the most preferred.
  preferredDuringSchedulingIgnoredDuringExecution: Listing<PreferredDuringSchedulingIgnoredDuringExecution>?

  /// If the anti-affinity requirements specified by this field are not met at scheduling time, the pod
  /// will not be scheduled onto the node. If the anti-affinity requirements specified by this field
  /// cease to be met at some point during pod execution (e.g. due to a pod label update), the system may
  /// or may not try to eventually evict the pod from its node. When there are multiple elements, the
  /// lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be
  /// satisfied.
  requiredDuringSchedulingIgnoredDuringExecution: Listing<RequiredDuringSchedulingIgnoredDuringExecution>?
}

/// Security configuration
class Security {
  /// If set, create an AWS PodIdentityAssociation using the ACK CRD in order to give the Restate pod
  /// access to this role and allow the cluster to reach the Pod Identity agent.
  awsPodIdentityAssociationRoleArn: String?

  /// If set, create an AWS SecurityGroupPolicy CRD object to place the Restate pod into these security
  /// groups
  awsPodSecurityGroups: Listing<String>?

  /// Egress rules to allow the cluster to make outbound requests; this is in addition to the default of
  /// allowing public internet access and cluster DNS access. Providing a single empty rule will allow
  /// all outbound traffic - not recommended
  networkEgressRules: Listing<NetworkPolicy.NetworkPolicyEgressRule>?

  /// Network peers to allow inbound access to restate ports If unset, will not allow any new traffic.
  /// Set any of these to [] to allow all traffic - not recommended.
  networkPeers: NetworkPeers?

  /// If set, configure the use of a private key to sign outbound requests from this cluster
  requestSigningPrivateKey: RequestSigningPrivateKey?

  /// Annotations to set on the ServiceAccount created for Restate
  serviceAccountAnnotations: Mapping<String, String>?

  /// Annotations to set on the Service created for Restate
  serviceAnnotations: Mapping<String, String>?
}

/// Network peers to allow inbound access to restate ports If unset, will not allow any new traffic. Set
/// any of these to [] to allow all traffic - not recommended.
class NetworkPeers {
  admin: Listing<NetworkPolicy.NetworkPolicyPeer>?

  ingress: Listing<NetworkPolicy.NetworkPolicyPeer>?

  metrics: Listing<NetworkPolicy.NetworkPolicyPeer>?
}

/// If set, configure the use of a private key to sign outbound requests from this cluster
class RequestSigningPrivateKey {
  /// A Kubernetes Secret source for the private key
  secret: Secret?

  /// A CSI secret provider source for the private key; will create a SecretProviderClass.
  secretProvider: SecretProvider?

  /// The version of Restate request signing that the key is for; currently only "v1" accepted.
  version: String
}

/// A Kubernetes Secret source for the private key
class Secret {
  /// The key of the secret to select from. Must be a valid secret key.
  key: String

  /// Name of the secret.
  secretName: String
}

/// A CSI secret provider source for the private key; will create a SecretProviderClass.
class SecretProvider {
  /// Configuration for specific provider
  parameters: Mapping<String, String>?

  /// The path of the private key relative to the root of the mounted volume
  path: String

  /// Configuration for provider name
  provider: String?
}

/// Storage configuration
class Storage {
  /// storageClassName is the name of the StorageClass required by the claim. More info:
  /// https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1 this field is immutable
  storageClassName: String?

  /// storageRequestBytes is the amount of storage to request in volume claims. It is allowed to increase
  /// but not decrease.
  storageRequestBytes: Int(this >= 1.0)
}

/// Status of the RestateCluster. This is set and managed automatically. Read-only. More info:
/// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
class Status {
  conditions: Listing<Condition>?
}

class Condition {
  /// Last time the condition transitioned from one status to another.
  lastTransitionTime: String?

  /// Human-readable message indicating details about last transition.
  message: String?

  /// Unique, one-word, CamelCase reason for the condition's last transition.
  reason: String?

  /// Status is the status of the condition. Can be True, False, Unknown.
  status: String

  /// Type of the condition, known values are (`Ready`).
  type: String
}
